---
title: "Linear regression in SCP"
subtitle: "Resolving the issue of msqrob2"
author: "Léopold Guyot"
institute: "UGent"
date: "24/07/2024"
output:
  xaringan::moon_reader:
    css: styles.css
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: false
      navigation:
        scroll: false

---

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_tile_view()  ## use o to get an overview
xaringanExtra::use_fit_screen() ## use Alt-F to fit to screen
xaringanExtra::use_extra_styles(
  hover_code_line = TRUE
  )
xaringanExtra::use_panelset()
```

``` {r packages, include=FALSE}

library(QFeatures)
library(msqrob2)
library(limma)
library(scp)
library(BiocParallel)
library(tidyverse)
library(plotly)
library(DT)
library(lme4)
library(UpSetR)

```

# Outlines

.bigger1-5[
1. Theoretical Introduction
2. Presentation of the different methods
3. Application on specific peptides
4. Application on a global analysis
5. Benchmark of the methods
]

---

# Theoretical Introduction

### Matrix Computation Least Square
### QR Decomposition
### Pivoting and rank

---
# Matrix Computation Least Square

.bigger1-3[
- In the least square method, we want to minimize the sum of the square of the residuals.
- The model can be represented in matrix form as $y = X\beta + \epsilon$.
- And the solution of the least square is $\hat{\beta} = (X^TX)^{-1}X^Ty$.

- Drawbacks:
  - The solution is not always possible, especially when the matrix $X^TX$ is singular.
  - This model can be computationally expensive.
]

---
# QR Decomposition

.bigger1-3[

- QR decomposition: Factorizes a matrix X into an orthogonal matrix Q and an upper triangular matrix R.
- This decomposition can be used in the classical linear equation.
- We obtain $R\beta = Q^Ty$, which can be solved for β using back-substitution.

- Advantages:
  - More numerically stable compared to directly solving normal equations. (avoid problem with matrix inversion)
  - There are efficient algorithms to solve this equation.
]
---
# Pivoting and Rank Deficiency

### Pivoting

.bigger1-3[
- Pivoting is the process of reordering the rows of a matrix to improve the numerical stability of the matrix factorization.
]

### Rank Deficiency

.bigger1-3[
- A matrix is rank deficient if it does not have full rank, which means that some columns are linearly dependent.

=> The full rank can be restored by dropping some columns of the matrix.
]
---

# Presentation of the different methods

### scplainer
### limma
### msqrob2

---

# scplainer

.bigger1-3[
- Based on ridge linear regression

- Regression obtained using basic matrix algebra

- Missing values are subsetted out before proceeding the regression.

- This subset ensure that the model is not rank defficient​
]

---
# limma

.panelset[
.panel[
.panel-name[lmFit]
.bigger1-3[
- Based on basic least square linear regression

- Function notEstimable report the different coefficient that are not estimable (linearly dependent parameters). This is done via qr(). Note that this is made before the subsetting therefore only some of the coefficients will be considered not estimable while in reality there are more coefficients not estimable after the subsetting​


- Use lm.fit to carry out the regression

- Does not check for rank defficienty in the model, just return the estimatable coefficients​

]
]
.panel[
.panel-name[contrasts.fit]
.bigger1-3[
- contrasts.fit is used to estimate coefficients for contrasts.

- This function ensure that the contrast involve only estimable contrast (via the use of the pivot object of the fit (estimated pivot[1:nrow(contrasts)])

- During the operations NAs are replaced by coefficient value of zero and enormous variance. These values are retransformed at the end into NAs
]
]
]


---

# msqrob2

.bigger1-3[

- Based on basic least square linear regression

- The regression is carried out by lm.fit which use qr decomposition​

- A subset of the response vector and of the model matrix is made. Coefficients of the model matrix with no values are removed

- Using a subsetting when the model matrix is already constructed makes unable to check the completeness of the groups burried in the interecept. Therefore when a reference group has no values, the model is rank defficient​

- Within the algorithm there is a check to see if the model is rank defficient, if this is the case nothing is returned for the concerned feature => This is what cause the issue of low number of features fitted​
]

---

# Modified version of msqrob
.panelset[
.panel[
.panel-name[Comments]
.bigger1[
- The issue with msqrobLm is that it does not allow the case where the model
is rank deficient.
- msqrobLm already include a subsetting of the design matrix to remove columns
that have no information (i.e. all zeros). But it does not handle the case
where the reference group of a variable has no values, in this case the model
become rank deficient.
- A first solution would be to change the condition to let rank defficient model to be estimated. But for the robust case, msqrob use rlm from MASS which throw an error when the model is rank defficient.
- To solve this issue, we changed the way the subset is performed by only
keeping the x first columns of the design matrix, with columns sorted by their
pivoting rank and x being the rank of the qr decomposition of the design matrix.

- Note that we should maybe also implement a check for the completeness of the variable (check if each variable is represented by at least 2 groups)
]
]
.panel[
.panel-name[Code]

.scrollable[
```{r msqrobLm_modif}

msqrobLm_fix <- function (y, formula, data, robust = TRUE, maxitRob = 5) 
{
    myDesign <- model.matrix(formula, data)
    models <- apply(y, 1, function(y, design) {
        obs <- is.finite(y)
        type <- "fitError"
        model <- list(coefficients = NA, vcovUnscaled = NA, 
            sigma = NA, df.residual = NA, w = NA)
        if (sum(obs) > 0) {
            X <- design[obs, , drop = FALSE]
            qrX <- qr(X)
            X <- X[, qrX$pivot[seq_len(qrX$rank)], drop = FALSE] # change
            # => old version
            # X <- X[, colMeans(X == 0) != 1, drop = FALSE] 
            y <- y[obs]
            colnames_orig <- colnames(design)
            if (robust) {
                mod <- try(MASS::rlm(X, y, method = "M", maxit = maxitRob), 
                    silent = TRUE)
                if (!is(mod, "try-error")) {
                    type <- "rlm"
                }
            }
            else {
                mod <- try(lm.fit(X, y))
                if ((!is(mod, "try-error")) & mod$rank == ncol(X)) {
                    type <- "lm"
                }
            }
            if (type == "rlm") {
                w <- mod$w
                sigma <- sqrt(sum(mod$w * mod$resid^2)/(sum(mod$w) - 
                    mod$rank))
                df.residual <- sum(mod$w) - mod$rank
                if (df.residual < 2L) 
                    type <- "fitError"
            }
            if (type == "lm") {
                w <- NULL
                sigma <- sqrt(sum(mod$residuals^2/mod$df.residual))
                df.residual <- mod$df.residual
                if (df.residual < 2L) 
                    type <- "fitError"
            }
            if (type != "fitError") {
                coef <- rep(NA, length(colnames_orig))
                names(coef) <- colnames_orig
                coef[names(mod$coef)] <- mod$coef
                vcovUnscaled <- matrix(NA, nrow = length(colnames_orig), 
                    ncol = length(colnames_orig))
                rownames(vcovUnscaled) <- colnames(vcovUnscaled) <- colnames_orig
                vcovUnscaled[names(mod$coef), names(mod$coef)] <- msqrob2:::.vcovUnscaled(mod)
                model <- list(coefficients = mod$coef, vcovUnscaled = msqrob2:::.vcovUnscaled(mod), 
                    sigma = sigma, df.residual = df.residual, 
                    w = w)
            }
        }
        .StatModel(type = type, params = model, varPosterior = as.numeric(NA), 
            dfPosterior = as.numeric(NA))
    }, design = myDesign)
    hlp <- limma::squeezeVar(var = vapply(models, getVar, numeric(1)), 
        df = vapply(models, getDF, numeric(1)))
    for (i in seq_len(length(models))) {
        mydf <- hlp$df.prior + getDF(models[[i]])
        models[[i]]@varPosterior <- as.numeric(hlp$var.post[i])
        models[[i]]@dfPosterior <- as.numeric(mydf)
    }
    return(models)
}


### msqrob2::msqrob with the new msqrobLm

msqrob_fix <-  .local <- function (object, formula, modelColumnName = "msqrobModels", 
        overwrite = FALSE, robust = TRUE, ridge = FALSE, maxitRob = 1, 
        tol = 1e-06, doQR = TRUE, lmerArgs = list(control = lmerControl(calc.derivs = FALSE))) 
    {
        if (ncol(colData(object)) == 0) 
            stop("colData is empty")
        if ((modelColumnName %in% colnames(rowData(object))) & 
            !overwrite) {
            stop("There is already a column named '", modelColumnName, 
                "' in the rowData of the SummarizedExperiment object, set the argument overwrite=TRUE to replace the column with the new results or use another name for the argument modelColumnName to store the results as a novel column in the rowData of SummarizedExperiment object")
        }
        if (length(formula) == 3) {
            formula <- formula[-2]
        }
        if (any(all.vars(formula) %in% colnames(rowData(object)))) {
            stop("Use the msqrobAggregate function to use rowData variables")
        }
        check_vars <- all.vars(formula) %in% colnames(colData(object))
        if (!all(check_vars)) {
            if (sum(!check_vars) > 1) {
                vars_not_found <- paste0(all.vars(formula)[!check_vars], 
                    collapse = ", ")
                stop(paste("Variables", vars_not_found, "are not found in coldata"), 
                    sep = "")
            }
            else {
                vars_not_found <- all.vars(formula)[!check_vars]
                stop(paste0("Variable ", vars_not_found, " is not found in coldata"), 
                    sep = "")
            }
        }
        if (!ridge & is.null(findbars(formula))) {
            rowData(object)[[modelColumnName]] <- msqrobLm_fix(y = assay(object), 
                formula = formula, data = droplevels(colData(object)), 
                robust = robust, maxitRob = maxitRob)
        }
        else {
            rowData(object)[[modelColumnName]] <- msqrobLmer(y = assay(object), 
                formula = formula, data = droplevels(colData(object)), 
                rowdata = NULL, robust = robust, maxitRob = maxitRob, 
                tol = tol, doQR = doQR, ridge = ridge, lmerArgs = lmerArgs)
        }
        rowData(object)[[modelColumnName]] <- rowData(object)[[modelColumnName]][rownames(rowData(object))]
        return(object)
    }
```

]
]
]

---
class: center, middle

# Application on specific peptides

---

# Data loading

.panelset[
.panel[
.panel-name[Code]

```{r data_loading}

.createMockBalanced <- function(k, runs) {
    out <- split(runs, runs)
    out <- lapply(out, function(x) {
        index <- 1:length(x)
        x[sample(index)] <- rep(1:k, length.out = length(index))
        x
    })
    out <- S4Vectors::unname(do.call(c, out))
    as.factor(out)
}

sce <- readRDS("data/leduc_mock.rds")
set.seed(1234)
sce$Mock <- .createMockBalanced(2, sce$Set)

colData(sce) <- droplevels(colData(sce))

```
]

.panel[
.panel-name[Preview]

```{r sce_preview}
sce
```
]
]


---
class:middle

# Subset of specific peptides
.scrollable[
### Non fitted
Model for a peptide that is not fitted neither for scplainer and msqrob2

```{r nfit}
non_fitted <- sce["AAATAEEPDPK_2",]
print(paste("Number of observed values: ", sum(is.finite(assay(non_fitted)[1,]))))
```
### Fitted with each method
Model for a peptide that is fitted for each method

```{r fit}
fitted <- sce["GAEAANVTGPGGVPVQGSK_3",]
print(paste("Number of observed values: ", sum(is.finite(assay(fitted)[1,]))))
```

### Non fitted with msqrob2
Model for a peptide that is not fitted only for msqrob2

```{r nfit_msqrob}
non_fitted_msqrob <- sce["EATTEFSVDAR_2",]
print(paste("Number of observed values: ", sum(is.finite(assay(non_fitted_msqrob)[1,]))))
```
]

---

class:

# Modelling

.panelset[
.panel[
.panel-name[Non fitted]

```{r modelling_nfit, results = 'hide', warning=FALSE}
scp_nfit <- scp::scpModelWorkflow(non_fitted,
                             formula = ~ 1 + Channel + Set + Mock)
msqrobLm_nfit <- msqrobLm(assay(non_fitted),
                           ~ 1 + Channel + Set + Mock,
                           colData(non_fitted),
                           robust = FALSE)
msqrobLm_fix_nfit <- msqrobLm_fix(assay(non_fitted),
                           ~ 1 + Channel + Set + Mock,
                           colData(non_fitted),
                           robust = FALSE)
y <- assay(non_fitted)
design <- model.matrix(~ 1 + Channel + Set + Mock, colData(non_fitted))
limma_nfit <- limma::lmFit(y, design)
```
]

.panel[
.panel-name[Fitted with each method]


```{r modelling_fit, results = 'hide', warning=FALSE}
scp_fit <- scp::scpModelWorkflow(fitted,
                            formula = ~ 1 + Channel + Set + Mock)
msqrobLm_fit <- msqrobLm(assay(fitted),
                            ~ 1 + Channel + Set + Mock,
                            colData(fitted),
                            robust = FALSE)
msqrobLm_fix_fit <- msqrobLm_fix(assay(fitted),
                            ~ 1 + Channel + Set + Mock,
                            colData(fitted),
                            robust = FALSE)
y <- assay(fitted)
design <- model.matrix(~ 1 + Channel + Set + Mock, colData(fitted))
limma_fit <- limma::lmFit(y, design)
```

]
.panel[
.panel-name[Non fitted with msqrobLm]


```{r modelling_fit_msqrob, results = 'hide', warning=FALSE}
scp_nfit_msqrob <- scp::scpModelWorkflow(non_fitted_msqrob,
                                          formula = ~ 1 + Channel + Set + Mock)
msqrobLm_nfit_msqrob <- msqrobLm(assay(non_fitted_msqrob),
                                        ~ 1 + Channel + Set + Mock,
                                        colData(non_fitted_msqrob),
                                        robust = FALSE)
msqrobLm_fix_nfit_msqrob <- msqrobLm_fix(assay(non_fitted_msqrob),
                                        ~ 1 + Channel + Set + Mock,
                                        colData(non_fitted_msqrob),
                                        robust = FALSE)
y <- assay(non_fitted_msqrob)
design <- model.matrix(~ 1 + Channel + Set + Mock, colData(non_fitted_msqrob))
limma_nfit_msqrob <- limma::lmFit(y, design)
```

]


]
---

# Results non fitted

.panelset[
.panel[
.panel-name[Success Results Comments]
.bigger1-3[
- The scplainer model returns a NP ratio that is less than 1, which means that 
this model is not usable in the scplainer workflow. But some coefficients are
still estimated due to the use of a ridge regression.
- Both msqrobLm and msqrobLm fixed models return a fitError model, which means that the models are not
estimable
- The limma model returns some coefficients, which means that the model still
return a normal output even with poor data (only 26 observations on 818 samples). This can cause a problem since these coefficients are not reliable, and will be taken into account in the multiple test correction.
]
]

.panel[
.panel-name[Success Results Code]
.scrollable[
```{r results_nfit}

result_scp_nfit <- scpModelFilterNPRatio(scp_nfit, filtered = FALSE)
result_msqrobLm_nfit <- msqrobLm_nfit[[1]]@type
result_msqrobLm_fix_nfit <- msqrobLm_fix_nfit[[1]]@type
result_limma_nfit <- sum(!is.na(limma_nfit$coefficients))

print(paste("The scplainer model return a NP ratio that is equal to",
            result_scp_nfit))
print("Some coefficients are still estimated due to theuse of a ridge regression.")
print(paste("The msqrob model return a",
            result_msqrobLm_nfit,
            "model."))
print(paste("The msqrob model with the fix return a"
            , result_msqrobLm_fix_nfit,
            "model."))
print(paste("The limma model return",
            result_limma_nfit,
            "coefficients."))
```
]]
]
---

# Results fitted with each method

.panelset[
.panel[
.panel-name[Success Results Comments]
.bigger1-3[
As intended, each method fitted a model for the peptide. scplainer returns a 
NP ration larger than 1 indicating that the model is usable in the scplainer
workflow. And both the normal and fixed msqrob return a model. limma also returns
a model.
]
]
.panel[
.panel-name[Success Results Code]
.scrollable[
```{r results_fit}

result_scp_fit <- scp::scpModelFilterNPRatio(scp_fit, filtered = FALSE)
result_msqrobLm_fit <- msqrobLm_fit[[1]]@type
result_msqrobLm_fix_fit <- msqrobLm_fix_fit[[1]]@type
result_limma_fit <- sum(!is.na(limma_fit$coefficients))

print(paste("The scplainer model return a NP ratio that is equal to",
            result_scp_fit))
print(paste("The msqrob model return a",
            result_msqrobLm_fit,
            "model."))
print(paste("The msqrob model with the fix return a"
            , result_msqrobLm_fix_fit,
            "model."))
print(paste("The limma model return",
            result_limma_fit,
            "coefficients."))
```
]]
]
---

# Results fitted with each method
.panelset[
.panel[
.panel-name[Coefficients Results Comments]
.bigger1-3[
- scplainer is not used in the coefficients comparison since during the model fitting, scplainer modify the reference group of the variable to avoid rank defficiency. This can cause a difference in the coefficients.

- As we can see with the 3D plot, the coefficients returned by msqrobLm, msqrobLm fixed and limma are identical.
]
]
.panel[
.panel-name[Coefficients results Code]
.scrollable[

```{r coef_fit}
coef_msqrobLm_fit <- getCoef(msqrobLm_fit[[1]])
coef_msqrobLm_fix_fit <- getCoef(msqrobLm_fix_fit[[1]])
coef_limma_fit <- limma_fit$coefficients


summary_coef_fit <- full_join(full_join(
      data.frame("parameter" = names(coef_msqrobLm_fit),
                    "coefficient_msqrobLm" = coef_msqrobLm_fit),
      data.frame("parameter" = names(coef_msqrobLm_fix_fit),
                    "coefficient_msqrobLm_fix" = coef_msqrobLm_fix_fit),
      by = "parameter"),
      data.frame("parameter" = colnames(coef_limma_fit),
                    "coefficient_limma" = as.numeric(coef_limma_fit)),
      by = "parameter")

fig <- plot_ly(summary_coef_fit, x = ~coefficient_msqrobLm,
               y = ~coefficient_msqrobLm_fix,
               z = ~coefficient_limma,
               type = 'scatter3d',
               mode = 'markers+lines',
               marker = list(size = 5), line = list(width = 2),
               width = 1000, height = 400)

fig <- fig %>%
  layout(scene = list(xaxis = list(title = 'msqrob2'),
                      yaxis = list(title = 'msqrob2 fix'),
                      zaxis = list(title = 'limma')))
```
]]

.panel[
.panel-name[Coefficients results Plot]
```{r coef_fit_plot, echo=FALSE}
fig
```
]]

---

# Results non fitted with msqrob2

.panelset[
.panel[
.panel-name[Success Results Comments]
.bigger1-3[
- As we can expect, only msqrobLm returns a fitError object. This show us that the fix enable the estimation of some unestimable peptides.
]
]
.panel[
.panel-name[Success Results Code]
.scrollable[
```{r results_nfit_msqrob}

result_scp_nfit_msqrob <- scp::scpModelFilterNPRatio(scp_nfit_msqrob, filtered = FALSE)
result_msqrobLm_nfit_msqrob <- msqrobLm_nfit_msqrob[[1]]@type
result_msqrobLm_fix_nfit_msqrob <- msqrobLm_fix_nfit_msqrob[[1]]@type
result_limma_nfit_msqrob <- sum(!is.na(limma_nfit_msqrob$coefficients))

print(paste("The scplainer model return a NP ratio that is equal to",
            result_scp_nfit_msqrob))
print(paste("The msqrobLm model return a",
            result_msqrobLm_nfit_msqrob,
            "model."))
print(paste("The msqrobLm model with the fix return a"
            , result_msqrobLm_fix_nfit_msqrob,
            "model."))
print(paste("The limma model return",
            result_limma_nfit_msqrob,
            "coefficients."))
```
]]
]

---

# Results non fitted with msqrob2

.panelset[
.panel[
.panel-name[Coefficients Results Comments]
.bigger1-3[
- We can see that when we compare the coefficients of the msqrobLm fix and limma, the coefficients are identical. This shows us that the estimation of the new msqrobLm is reliable.
]
]
.panel[
.panel-name[Coefficients Results Code]
.scrollable[

```{r coef_nfit_msqrob}
coef_msqrobLm_nfit_msqrob <- getCoef(msqrobLm_nfit_msqrob[[1]])
coef_msqrobLm_fix_nfit_msqrob <- getCoef(msqrobLm_fix_nfit_msqrob[[1]])
coef_limma_nfit_msqrob <- limma_nfit_msqrob$coefficients


summary_coef_nfit_msqrob <- full_join(data.frame("parameter" = names(coef_msqrobLm_fix_nfit_msqrob),
                    "coefficient_msqrobLm_fix" = coef_msqrobLm_fix_nfit_msqrob),
      data.frame("parameter" = colnames(coef_limma_nfit_msqrob),
                    "coefficient_limma" = as.numeric(coef_limma_nfit_msqrob)), by = "parameter")

fig <- ggplot(summary_coef_nfit_msqrob, aes(x = coefficient_msqrobLm_fix, y = coefficient_limma)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  labs(x = "msqrob2 fix", y = "limma")
```
]]

.panel[
.panel-name[Coefficients Results Plot]
.scrollable[
```{r coef_nfit_msqrob_plot, echo=FALSE, warning=FALSE}
ggplotly(fig)
```
]
]]

---

# Comparaison on a set of peptides

.panelset[
.panel[
.panel-name[Comments]
.bigger1-3[
We can see that a large number of features are estimated by limma scplainer and the msqrob fix.
While the msqrob model is not able to estimate the same number of features. We can also note that some features are only estimated by limma or by scplainer due to the difference in the model method.
]
]

.panel[
.panel-name[Code]
.scrollable[
```{r subset_peptides}

# create a subset of peptides using 2000 peptides
num_features <- 2000  # Number of features to sample
total_features <- nrow(sce)

subset <- sce[sample(1:total_features, num_features),]
colData(subset) <- droplevels(colData(subset))
```

```{r subset_modelling, results = 'hide', warning=FALSE}

subset_msqrob <-  msqrob(subset,
                           formula = ~ 1 + Channel + Set + Mock,
                           robust = FALSE,
                           ridge = FALSE)
subset_msqrob_fix <- msqrob_fix(subset,
                           formula = ~ 1 + Channel + Set + Mock,
                           robust = FALSE,
                           ridge = FALSE)
subset_limma <- limma::lmFit(assay(subset),
                            model.matrix(~ 1 + Channel + Set + Mock,
                                         colData(subset)))
subset_scp <- scp::scpModelWorkflow(subset,
                                   formula = ~ 1 + Channel + Set + Mock)
```

``` {r contrasts, results = 'hide', warning=FALSE}
design <- model.matrix(~ 1 + Channel + Set + Mock, colData(subset))

L_limma <- makeContrasts(Mock2, levels = design)
contrast_limma <- contrasts.fit(subset_limma, L_limma)
contrast_limma <- eBayes(contrast_limma)
contrast_limma <- topTable(contrast_limma, sort.by = "p", number = 2000)

L_msqrob <- makeContrast(c("Mock2 = 0"), parameterNames = colnames(design))
contrast_msqrob <- hypothesisTest(subset_msqrob, contrast = L_msqrob)
contrast_msqrob <- rowData(contrast_msqrob)$Mock2

contrast_msqrob_fix <- hypothesisTest(subset_msqrob_fix, contrast = L_msqrob)
contrast_msqrob_fix <- rowData(contrast_msqrob_fix)$Mock2

contrast_scp <- scp::scpDifferentialAnalysis(subset_scp, contrasts = list(c("Mock", "2", "1")))
contrast_scp <- contrast_scp[[1]] %>% 
  as.data.frame()
rownames(contrast_scp) <- contrast_scp$feature
```

]]
.panel[
.panel-name[Contrasts Sets]
.scrollable[

``` {r contrasts_sets, fig.width=10, fig.height=8}
# change to use the number of estimated features
set_limma <- contrast_limma %>% 
  filter(!is.na(logFC)) %>%
  rownames()

set_msqrob <- contrast_msqrob %>%
  filter(!is.na(logFC)) %>% 
  rownames()

set_msqrob_fix <- contrast_msqrob_fix %>%
  filter(!is.na(logFC)) %>%
  rownames()

set_scplainer <- contrast_scp %>%
  filter(!is.na(Estimate)) %>% 
  rownames()

sets <- list(
  limma = set_limma,
  msqrob = set_msqrob,
  msqrob_fix = set_msqrob_fix,
  scplainer = set_scplainer
)
upset(fromList(sets), order.by = "freq")

```

]]
.panel[
.panel-name[Contrasts Tables]
.scrollable[
``` {r contrasts_dfs}
common_rows <- Reduce(intersect,
                      list(rownames(contrast_msqrob),
                           rownames(contrast_limma),
                           rownames(contrast_scp),
                           rownames(contrast_msqrob_fix)))
DT::datatable(contrast_msqrob[common_rows,])
DT::datatable(contrast_msqrob_fix[common_rows,])
DT::datatable(contrast_limma[common_rows,])
DT::datatable(contrast_scp[common_rows,])

```
]
]]

---

# Benchmark of the methods
.panelset[
.panel[
.panel-name[Variable input size]


.scrollable[

```{r benchmark}
bench_res <- read.csv("data_output/benchmark_results.csv")
bench_res$secondes<- bench_res$time/(1e9)

ggplotly(ggplot(bench_res, aes(x = featureNumber, y = secondes, color = Method)) +
           geom_boxplot(),
         width = 800, height = 400
         ) # influence of the non estimation on msqrob
```
]]

.panel[
.panel-name[Only modelled features]
.scrollable[
```{r benchmark_modelled}
# bench_res <- read.csv("data_output/benchmark_results.csv")
# bench_res$secondes<- bench_res$time/(1e9)
# 
# ggplotly(ggplot(bench_res, aes(x = featureNumber, y = secondes, color = Method)) +
#            geom_boxplot(),
#          width = 800, height = 400
#          )
```

]
]
]
